/**
 * UserProfileUtil
 */
package com.boa.eagls.government.util;

import java.util.Properties;
import java.util.StringTokenizer;

import com.boa.eagls.government.dto.HierarchyDTO;
import org.apache.log4j.Logger;

/**
 * The String Generated by the encoder will be : if the Role Type is AH : !roleType+accnumber1.accnumber2.accnumber3.
 * if the Role Type is GSA, FMS, PC : !roleType+hierarchy1-hierarchy2-hierarchy3.description1-description2-description3.
 * if the Role Type is PC then along with the above string : programtype1-programtype2-programtype3. will be appended.
 * The Prefix "!' is used to indicate a begining of a new role.
 * The delimiter "+" is used to seperate out roletype with the remainder of the role string.
 * The delimiter strPeriod is used to seperate out hierarchies, descriptions, programtypes
 * and accountnumbers.  Character copied from textpad - replaces (".").
 * The delimiter strDash is used to seperate out individual hierarchies, descriptions and
 * programtypes. Character copied from textpad - replaces ("-"). <p>Title: </p> <p>Description: </p>
 * <p>Copyright: Copyright (c) 2003</p> <p>Company: </p>
 * @author not attributable
 * @version 1.0
 */
public class UserProfileUtil
{
    private static Logger logger =
            Logger.getLogger(com.boa.eagls.government.controller.action.user.LogonAction.class);
    static String strPeriod = "Ú";
    static String strDash = "Ý";

    /**
     * Method declaration
     *
     *
     * @param role
     * @param sentence
     *
     * @return
     */
    public static String encodeRole(String role, String sentence)
    {

        // Precede the RoleType with "!", to indicate a start of new RoleType.
        // Append "+" to indicate the end of RoleType.
        return sentence + "!" + role + "+";
    }

    /**
     * Method declaration
     *
     *
     * @param accNumber
     * @param sentence
     *
     * @return
     */
    public static String encodeAccountNumber(String accNumber,
                                             String sentence)
    {

        // Append "." to indicate the end of individualaccount number.
        return sentence + accNumber + strPeriod;
    }

    /**
     * Method declaration
     *
     *
     * @param hier
     * @param description
     * @param sentence
     *
     * @return
     */
    public static String encodeHierarchy(String[] hier, String[] description,
                                         String sentence)
    {
        for (int j = 0; j < hier.length; j++)
        {

            // Use "-" to separate out two hierarchies.
            sentence = sentence + hier[j] + strDash;
        }

        // Append "." to indicate the end of hierarchy sequence.
        sentence = sentence + strPeriod;
        for (int j = 0; j < description.length; j++)
        {

            // Use "-" to separate out two descriptions.
            sentence = sentence + description[j] + strDash;
        }

        // Append "." to indicate the end of description.
        return sentence + strPeriod;
    }

    /**
     * Method declaration
     *
     *
     * @param programType
     * @param sentence
     *
     * @return
     */
    public static String encodeProgramType(String[] programType,
                                           String sentence)
    {
        for (int j = 0; j < programType.length; j++)
        {

            // Use "-" to separate out two program types
            sentence = sentence + programType[j] + strDash;
        }

        // Append "." to indicate the end of program types.
        return sentence + strPeriod;
    }

    /**
     * Method declaration
     *
     *
     * @param sentence
     *
     * @return
     */
    public static RoleUtil[] decodeRole(String sentence)
    {

        // Append "^" to indicate the end of last role type.
        StringTokenizer strToken = new StringTokenizer(sentence + "^", "!^",
                false);
        int count = strToken.countTokens();
        RoleUtil[] roleArray = new RoleUtil[count];

        for (int i = 0; i < count; i++)
        {
            String tempStr = strToken.nextToken();

            roleArray[i] = new RoleUtil();

            // Use "~" to separate out the role and the rest of the string.
            StringTokenizer tempToken = new StringTokenizer(tempStr + "~",
                    "+~", false);

            roleArray[i].roleType = tempToken.nextToken();
            roleArray[i].roleRemainder = tempToken.hasMoreElements()
                    ? tempToken.nextToken() : "";
        }
        return roleArray;
    }

    /**
     * Method declaration
     *
     *
     * @param sentence
     *
     * @return
     */
    public static AcctNumberUtil[] decodeAccountNumber(String sentence)
    {

        // use strToken to determine the number of individualaccount numbers in the string.
        StringTokenizer strToken = new StringTokenizer(sentence, strPeriod,
                false);
        int count = strToken.countTokens();
        AcctNumberUtil accNumberArray[] = new AcctNumberUtil[count];

        for (int i = 0; i < count; i++)
        {
            accNumberArray[i] = new AcctNumberUtil();

            // extract the individualaccount numbers here.
            accNumberArray[i].acctNumber = strToken.nextToken();
        }
        return accNumberArray;
    }

    /**
     * Method declaration
     *
     *
     * @param sentence
     *
     * @return
     */
    public static HierarchyUtil[] decodeHierarchy(String sentence)
    {

        // use strToken to determine the number of hierarchies in the string.
        StringTokenizer strToken = new StringTokenizer(sentence, strPeriod,
                false);
        int count = strToken.countTokens() / 2;
        HierarchyUtil hierarchyArray[] = new HierarchyUtil[count];

        for (int i = 0; i < count; i++)
        {
            String tempStr;
            int arrayIndex = 0;

            hierarchyArray[i] = new HierarchyUtil();
            for (int j = 0; j < 9; j++)
            {
                hierarchyArray[i].hierarchy[j] = new HierarchyDTO();
            }

            // get the nextColumn token.
            tempStr = strToken.nextToken();
            StringTokenizer token2 = new StringTokenizer(tempStr, strDash,
                    false);

            // extract the hierarchies here.
            while (token2.hasMoreTokens())
            {
                String x = token2.nextToken();

                hierarchyArray[i].hierarchy[arrayIndex] = new HierarchyDTO();
                hierarchyArray[i].hierarchy[arrayIndex++]
                        .setNumber(Integer.parseInt(x));
            }

            // get the nextColumn token.
            tempStr = strToken.nextToken();
            StringTokenizer token3 = new StringTokenizer(tempStr, strDash,
                    false);

            // extract the descriptions here.
            arrayIndex = 0;
            while (token3.hasMoreTokens())
            {
                hierarchyArray[i].hierarchy[arrayIndex++]
                        .setDescription(token3.nextToken());
            }
        }
        return hierarchyArray;
    }

    /**
     * Method declaration
     *
     *
     * @param sentence
     *
     * @return
     */
    public static HierarchyPTUtil[] decodeHierarchyPT(String sentence)
    {

        // use strToken to determine the number of hierarchies in the string.
        StringTokenizer strToken = new StringTokenizer(sentence, strPeriod,
                false);
        int count = strToken.countTokens() / 3;
        HierarchyPTUtil hierarchyPTArray[] = new HierarchyPTUtil[count];

        for (int i = 0; i < count; i++)
        {
            String tempStr;

            // --int tempCount = -1;
            int arrayIndex = 0;

            hierarchyPTArray[i] = new HierarchyPTUtil();

            // get the nextColumn token.
            tempStr = strToken.nextToken();
            StringTokenizer token2 = new StringTokenizer(tempStr, strDash,
                    false);

            // initialize hierarchy
            for (int j = 0; j < 9; j++)
            {
                hierarchyPTArray[i].hierarchy[j] =
                        new HierarchyDTO();    // Integer.shortValue(j), j, "");
            }
            while (token2.hasMoreTokens())
            {
                String x = token2.nextToken();

                hierarchyPTArray[i].hierarchy[arrayIndex++]
                        .setNumber(Integer.parseInt(x));
            }

            // get nextColumn token.
            tempStr = strToken.nextToken();
            StringTokenizer token3 = new StringTokenizer(tempStr, strDash,
                    false);

            // extract the descriptions here.
            arrayIndex = 0;
            while (token3.hasMoreTokens())
            {
                hierarchyPTArray[i].hierarchy[arrayIndex++]
                        .setDescription(token3.nextToken());
            }

            // get nextColumn token.
            tempStr = strToken.nextToken();
            StringTokenizer token4 = new StringTokenizer(tempStr, strDash,
                    false);

            // extract the program types here.
            while (token4.hasMoreTokens())
            {
                (hierarchyPTArray[i].programType)
                        .addElement(token4.nextToken());
            }
            (hierarchyPTArray[i].programType).trimToSize();
        }
        return hierarchyPTArray;
    }

    /**
     * Method declaration
     *
     *
     * @param role
     *
     * @return
     */
    public static String getNextPath(String role)
    {
        String baseRole = role;    // UserMaintenanceBO.getBaseRole(role);

        if (baseRole == null || baseRole.equals(""))
        {
            return "";
        }
        if (baseRole.equals(Constants.HL_FMS)
                || baseRole.equals(Constants.HL_GSA)
                || baseRole.equals(Constants.HL_TC)
                || baseRole.equals(Constants.HL_NFS)
                || baseRole.equals(Constants.HL_A))
        {
            return "UserProfileAddHierarchy";
        }
        else if (baseRole.equals(Constants.HL_A_OPC)
                || baseRole.equals(Constants.HL_TDO)
                || baseRole.equals(Constants.HL_DBO)
                || baseRole.equals(Constants.HL_NB_ACCTG)
                || baseRole.equals(Constants.HL_NB_ADM)
                || baseRole.equals(Constants.HL_CL))
        {
            return "UserProfileAddHierarchyPT";
        }
        else
        {    // role = "AH"
            return "UserProfileAddAccountNumber";
        }
    }

    /**
     * Method declaration
     *
     *
     * @param role
     *
     * @return
     */
    public static String getRoleType(String role)
    {
        String baseRole = role;    // UserMaintenanceBO.getBaseRole(role);

        if (baseRole == null || baseRole.equals(""))
        {
            return "";
        }
        if (baseRole.equals(Constants.HL_GCSU))
        {
            return Constants.ROLETYPE_GCSU;
        }
        else if (baseRole.equals(Constants.HL_FMS)
                || baseRole.equals(Constants.HL_GSA)
                || baseRole.equals(Constants.HL_TC)
                || baseRole.equals(Constants.HL_NFS)
                || baseRole.equals(Constants.HL_A))
        {
            return Constants.ROLETYPE_HIERARCHY;
        }
        else if (baseRole.equals(Constants.HL_A_OPC)
                || baseRole.equals(Constants.HL_TDO)
                || baseRole.equals(Constants.HL_DBO)
                || baseRole.equals(Constants.HL_NB_ACCTG)
                || baseRole.equals(Constants.HL_NB_ADM)
                || baseRole.equals(Constants.HL_CL))
        {
            return Constants.ROLETYPE_HIERARCHYPT;
        }
        else
        {    // role = "AH"
            return Constants.ROLETYPE_ACCOUNT;
        }
    }

    /**
     * Method declaration
     *
     *
     * @param hSearch
     * @param hUser
     * @param depth
     *
     * @return
     */
    public static int[] authorizeHierarchySearch(int hSearch[], int[] hUser,
                                                 short depth)
    {
        logger
                .debug("UserProfileUtil --> authorizeHierarchySearch() --> START  hSearch ");
        short i;		      // counter
        int hNew[] = new int[9];    // will hold new hierarchy

        if (depth < 0)
        {
            return null;
        }    // sanity check

        // if both hSearch and hUser are null just return an array
        // of wildcards.  This means the caller is GCSU searching
        // for on something other than hierarchy
        if (hSearch == null && hUser == null)
        {
            for (i = 0; i < 9; i++)
            {
                hNew[i] = -1;
            }
            return hNew;
        }

        // if hSearch is null then caller is not searching by hierarchy
        // but needs a hierarchy to restrict query access
        if (hSearch == null && hUser.length == 9)
        {
            for (i = 0; i < 9; i++)
            {
                hNew[i] = (hUser[i] > 0) ? hUser[i] : -1;
            }
            return hNew;
        }

        // hSearch is not null so caller wants to search based on hierarchy
        // first, reconstruct the query factoring in depth and wildcards
        if (hSearch != null)
        {
            for (i = 0; i < 9 && hSearch[i] == 0; i++)
            {

                // wildcard leading zeros to single level search
                hNew[i] = -1;
            }
            for (; i < 9 && hSearch[i] > 0; i++)
            {

                // copy search level(s)
                hNew[i] = hSearch[i];
            }
            for (short j = depth; i < 9 && j > 0; j--, i++)
            {

                // wildcard depth levels
                hNew[i] = -1;
            }
            for (; i < 9; i++)
            {

                // zero out remaining levels
                hNew[i] = 0;
            }
        }

        // second, check against user's hierarchy to authorize
        if (hUser == null)
        {
            logger
                    .debug("UserProfileUtil --> authorizeHierarchySearch() -->in huser == null returning hnew ");

            // user is GCSU with full access
            return hNew;
        }
        if (hUser.length > 9 && hNew.length > 9)
        {
            for (i = 0; i < 9 && hUser[i] > 0; i++)
            {
                if (hNew[i] == -1)
                {

                    // overwrite wildcards
                    hNew[i] = hUser[i];
                }
                else if (hNew[i] != hUser[i])
                {

                    // mismatch; authorization denied
                    return null;
                }
            }
        }
        return hNew;
    }

}
